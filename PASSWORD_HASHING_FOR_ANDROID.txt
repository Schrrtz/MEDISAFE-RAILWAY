================================================================================
                    PASSWORD HASHING SYSTEM EXPLANATION
              How MediSafe Hashes Passwords & Android Integration
================================================================================

IMPORTANT: YOU CANNOT AND SHOULD NOT READ/DECRYPT PASSWORDS FROM SUPABASE!
This document explains WHY and provides the CORRECT approach for Android apps.

================================================================================
                    HOW PASSWORD HASHING WORKS IN MEDISAFE
================================================================================

1. HASHING ALGORITHM
   - Algorithm: PBKDF2-HMAC-SHA256 (Password-Based Key Derivation Function 2)
   - Iterations: 600,000 (Django 5.2 default)
   - Salt: Random, unique per password (automatically generated)
   - Hash Length: 32 bytes (256 bits)

2. HASH FORMAT IN DATABASE
   When you store a password in Supabase, it looks like this:
   
   pbkdf2_sha256$600000$aB3xK9mP2nQ4rT6v$7fJ2kL9nM1pQ4rT6vY8zA3bC5dE7fG9hI1jK2lM3nO4pQ

   Breaking it down:
   ┌──────────────┬────────┬─────────────┬──────────────────────────────────┐
   │   Algorithm  │ Iterations │   Salt    │           Hash Value             │
   └──────────────┴────────┴─────────────┴──────────────────────────────────┘
   pbkdf2_sha256  $ 600000  $ aB3xK9mP... $ 7fJ2kL9nM1pQ4rT6vY8zA3bC5dE...

3. HOW HASHING HAPPENS (SIGNUP)
   
   Step 1: User submits plain password "MyPassword123"
   
   Step 2: Django receives password in signup() function
   
   Step 3: User.save() method is called
   
   Step 4: Model checks if password is already hashed:
           if not self.password.startswith(('pbkdf2_sha256$', 'bcrypt$', 'argon2')):
   
   Step 5: If not hashed, call make_password():
           self.password = make_password(self.password)
   
   Step 6: make_password() does this:
           a. Generate random salt (16 bytes)
           b. Run PBKDF2-HMAC-SHA256(password, salt, 600000 iterations)
           c. Format: "pbkdf2_sha256$600000$[salt]$[hash]"
   
   Step 7: Store hashed password in Supabase users.password column
   
   Result: "MyPassword123" → "pbkdf2_sha256$600000$aB3xK9mP$7fJ2kL..."

4. HOW PASSWORD VERIFICATION WORKS (LOGIN)
   
   Step 1: User submits username + plain password "MyPassword123"
   
   Step 2: Django calls authenticate(username=username, password=password)
   
   Step 3: authenticate() retrieves user from database:
           - Fetches hashed password from Supabase
           - Example: "pbkdf2_sha256$600000$aB3xK9mP$7fJ2kL..."
   
   Step 4: Django calls check_password(plain_password, hashed_password)
   
   Step 5: check_password() does this:
           a. Parse the hash to extract: algorithm, iterations, salt, stored_hash
           b. Run PBKDF2-HMAC-SHA256("MyPassword123", salt, 600000)
           c. Compare computed hash with stored_hash
           d. Return True if match, False if not
   
   Step 6: If True, return user object; if False, return None
   
   Step 7: Login succeeds or fails based on result

================================================================================
                    WHY YOU CANNOT DECRYPT PASSWORDS
================================================================================

CRITICAL UNDERSTANDING: Hashing is NOT encryption!

ENCRYPTION (Reversible):
   Plain Text --[Encrypt]--> Cipher Text --[Decrypt]--> Plain Text
   Example: "Hello" --[AES]-> "j3k2l1..." --[AES]-> "Hello"
   ✓ Can be reversed with key

HASHING (One-Way):
   Plain Text --[Hash]--> Hash Value --[CANNOT REVERSE]--> ❌
   Example: "MyPassword123" --[PBKDF2]-> "pbkdf2_sha256$600000$..." --[?]--> ❌
   ✗ Mathematically impossible to reverse

WHY HASHING IS ONE-WAY:
   1. Information Loss: 
      - Input: Unlimited length password
      - Output: Fixed 32-byte hash
      - Many possible inputs can produce same hash (collision)
   
   2. 600,000 Iterations:
      - Hash is rehashed 600,000 times
      - Each iteration destroys information
      - Even with supercomputers, would take billions of years to reverse
   
   3. Unique Salt:
      - Same password produces different hashes for different users
      - "MyPassword123" for User A: pbkdf2_sha256$600000$aB3xK9...$7fJ2k...
      - "MyPassword123" for User B: pbkdf2_sha256$600000$zY9wV...$3nM1p...
      - Rainbow tables (pre-computed hashes) are useless

SECURITY IMPLICATION:
   ✓ Even if attacker steals entire Supabase database
   ✓ Even if attacker has the hash "pbkdf2_sha256$600000$..."
   ✗ They CANNOT get the original password
   ✗ Brute force attack would take ~10,000 years for strong password

================================================================================
              WRONG APPROACH: Trying to Decrypt from Supabase
================================================================================

❌ WRONG: Android App Trying to Read Password from Supabase

// THIS WILL NOT WORK! ❌
String hashedPassword = supabase.query("SELECT password FROM users WHERE username = ?");
// hashedPassword = "pbkdf2_sha256$600000$aB3xK9mP$7fJ2kL..."

String plainPassword = decrypt(hashedPassword); // ❌ IMPOSSIBLE!
// No such function exists. Hashes cannot be decrypted.

if (userInputPassword.equals(plainPassword)) {  // ❌ WILL NEVER WORK
    // This will never execute because plainPassword cannot be obtained
}

WHY THIS FAILS:
   1. No decrypt() function exists for hashes
   2. Hashes are one-way by design
   3. Even if you try to compare hashes:
      - User types: "MyPassword123"
      - You compare: "MyPassword123" == "pbkdf2_sha256$600000$..."
      - Result: Always FALSE (comparing string to hash)

================================================================================
              CORRECT APPROACH: Server-Side Authentication
================================================================================

✅ CORRECT: Android App Uses Django API for Authentication

ARCHITECTURE:
   ┌─────────────────┐         ┌──────────────────┐         ┌──────────────┐
   │  Android App    │ HTTPS   │  Django Server   │  SSL    │  Supabase DB │
   │                 ├────────>│  (Your Backend)  ├────────>│  PostgreSQL  │
   │  User enters:   │         │                  │         │              │
   │  - Username     │         │  ✓ Validates     │         │  Stores:     │
   │  - Password     │         │  ✓ Hashes        │         │  - Hashed    │
   │    (plain text) │         │  ✓ Compares      │         │    passwords │
   └─────────────────┘         └──────────────────┘         └──────────────┘
         │                              │                          │
         │ POST /api/auth/login/        │ check_password()         │
         │ {username, password}         │                          │
         │                              │ SELECT password WHERE... │
         │<───────────────────────────  │<─────────────────────────│
         │ {success: true, token: ...}  │ Return hashed password   │
         │                              │                          │

STEP-BY-STEP FLOW:

1. USER OPENS ANDROID APP
   - User sees login screen
   - Enters: Username "john", Password "MyPassword123"

2. ANDROID APP SENDS REQUEST
   ```java
   // Android code
   String username = "john";
   String password = "MyPassword123";  // Plain text - sent over HTTPS
   
   JSONObject credentials = new JSONObject();
   credentials.put("username", username);
   credentials.put("password", password);
   
   // POST to Django API
   String url = "https://your-django-server.com/api/auth/login/";
   JsonObjectRequest request = new JsonObjectRequest(
       Request.Method.POST, url, credentials,
       response -> {
           // SUCCESS: Django validated password
           String token = response.getString("token");
           String userId = response.getString("user_id");
           String role = response.getString("role");
           
           // Save token for future requests
           saveAuthToken(token);
           
           // Navigate to home screen
           navigateToHome();
       },
       error -> {
           // FAILURE: Wrong password
           showError("Invalid username or password");
       }
   );
   ```

3. DJANGO SERVER RECEIVES REQUEST
   ```python
   # Django code (auth/views.py)
   def login(request):
       data = json.loads(request.body)
       username = data.get("username")
       password = data.get("password")  # Receives plain text
       
       # Django authenticate() handles everything
       user = authenticate(username=username, password=password)
       
       if user is not None:
           # Password is CORRECT
           # Django automatically:
           # 1. Retrieved hash from Supabase
           # 2. Extracted salt from hash
           # 3. Hashed input password with same salt + 600k iterations
           # 4. Compared computed hash with stored hash
           # 5. Returned user because they match
           
           return JsonResponse({
               "success": True,
               "token": generate_token(user),
               "user_id": user.user_id,
               "role": user.role
           })
       else:
           # Password is WRONG
           return JsonResponse({
               "success": False,
               "message": "Invalid credentials"
           }, status=401)
   ```

4. SUPABASE DATABASE INTERACTION
   ```sql
   -- Django executes this automatically:
   SELECT user_id, username, password, role 
   FROM users 
   WHERE username = 'john';
   
   -- Returns:
   -- user_id: 123
   -- username: john
   -- password: pbkdf2_sha256$600000$aB3xK9mP$7fJ2kL...
   -- role: patient
   ```

5. PASSWORD VERIFICATION PROCESS (Inside Django)
   ```python
   # This happens inside authenticate()
   stored_hash = "pbkdf2_sha256$600000$aB3xK9mP$7fJ2kL..."
   input_password = "MyPassword123"
   
   # Parse the hash
   algorithm, iterations, salt, stored_hash_value = stored_hash.split('$')
   # algorithm = "pbkdf2_sha256"
   # iterations = 600000
   # salt = "aB3xK9mP"
   # stored_hash_value = "7fJ2kL..."
   
   # Compute hash of input password with same salt and iterations
   computed_hash = pbkdf2_hmac(
       'sha256',
       input_password.encode('utf-8'),
       salt.encode('utf-8'),
       int(iterations)
   )
   
   # Compare hashes
   if computed_hash == stored_hash_value:
       return user  # Password correct
   else:
       return None  # Password wrong
   ```

6. ANDROID APP RECEIVES RESPONSE
   - If success: Store token, navigate to home
   - If failure: Show error message

================================================================================
                    ANDROID APP IMPLEMENTATION
================================================================================

1. DEPENDENCIES (build.gradle)
   ```gradle
   dependencies {
       // For HTTP requests
       implementation 'com.android.volley:volley:1.2.1'
       // OR
       implementation 'com.squareup.retrofit2:retrofit:2.9.0'
       implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
       
       // For secure token storage
       implementation 'androidx.security:security-crypto:1.1.0-alpha06'
   }
   ```

2. API SERVICE CLASS
   ```java
   public class AuthService {
       private static final String BASE_URL = "https://your-django-server.com/api/";
       private RequestQueue requestQueue;
       
       public void login(String username, String password, AuthCallback callback) {
           String url = BASE_URL + "auth/login/";
           
           JSONObject credentials = new JSONObject();
           try {
               credentials.put("username", username);
               credentials.put("password", password);
           } catch (JSONException e) {
               callback.onError("Failed to create request");
               return;
           }
           
           JsonObjectRequest request = new JsonObjectRequest(
               Request.Method.POST, url, credentials,
               response -> {
                   try {
                       boolean success = response.getBoolean("success");
                       if (success) {
                           String token = response.getString("token");
                           String userId = response.getString("user_id");
                           String role = response.getString("role");
                           callback.onSuccess(token, userId, role);
                       } else {
                           callback.onError("Login failed");
                       }
                   } catch (JSONException e) {
                       callback.onError("Invalid response");
                   }
               },
               error -> {
                   callback.onError("Network error: " + error.getMessage());
               }
           );
           
           requestQueue.add(request);
       }
       
       public interface AuthCallback {
           void onSuccess(String token, String userId, String role);
           void onError(String message);
       }
   }
   ```

3. SECURE TOKEN STORAGE
   ```java
   public class TokenManager {
       private static final String PREFS_NAME = "auth_prefs";
       private static final String KEY_TOKEN = "auth_token";
       
       // Use EncryptedSharedPreferences for security
       public static void saveToken(Context context, String token) {
           try {
               MasterKey masterKey = new MasterKey.Builder(context)
                   .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
                   .build();
               
               SharedPreferences prefs = EncryptedSharedPreferences.create(
                   context,
                   PREFS_NAME,
                   masterKey,
                   EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                   EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
               );
               
               prefs.edit().putString(KEY_TOKEN, token).apply();
           } catch (Exception e) {
               // Fallback to regular SharedPreferences
               SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, MODE_PRIVATE);
               prefs.edit().putString(KEY_TOKEN, token).apply();
           }
       }
       
       public static String getToken(Context context) {
           // Retrieve token using same encrypted method
           // ...
       }
       
       public static void clearToken(Context context) {
           // Clear token on logout
           // ...
       }
   }
   ```

4. MAKING AUTHENTICATED REQUESTS
   ```java
   public class ApiClient {
       public void getUserProfile(String userId, ProfileCallback callback) {
           String url = BASE_URL + "users/" + userId + "/profile/";
           String token = TokenManager.getToken(context);
           
           JsonObjectRequest request = new JsonObjectRequest(
               Request.Method.GET, url, null,
               response -> callback.onSuccess(response),
               error -> callback.onError(error.getMessage())
           ) {
               @Override
               public Map<String, String> getHeaders() {
                   Map<String, String> headers = new HashMap<>();
                   headers.put("Authorization", "Bearer " + token);
                   return headers;
               }
           };
           
           requestQueue.add(request);
       }
   }
   ```

5. LOGIN ACTIVITY
   ```java
   public class LoginActivity extends AppCompatActivity {
       private EditText usernameInput;
       private EditText passwordInput;
       private Button loginButton;
       private AuthService authService;
       
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_login);
           
           usernameInput = findViewById(R.id.username);
           passwordInput = findViewById(R.id.password);
           loginButton = findViewById(R.id.login_button);
           
           authService = new AuthService(this);
           
           loginButton.setOnClickListener(v -> {
               String username = usernameInput.getText().toString();
               String password = passwordInput.getText().toString();
               
               if (username.isEmpty() || password.isEmpty()) {
                   Toast.makeText(this, "Please fill all fields", Toast.LENGTH_SHORT).show();
                   return;
               }
               
               // Show loading
               loginButton.setEnabled(false);
               loginButton.setText("Logging in...");
               
               authService.login(username, password, new AuthService.AuthCallback() {
                   @Override
                   public void onSuccess(String token, String userId, String role) {
                       // Save token securely
                       TokenManager.saveToken(LoginActivity.this, token);
                       
                       // Navigate based on role
                       Intent intent;
                       if ("doctor".equals(role)) {
                           intent = new Intent(LoginActivity.this, DoctorDashboardActivity.class);
                       } else if ("patient".equals(role)) {
                           intent = new Intent(LoginActivity.this, PatientDashboardActivity.class);
                       } else {
                           intent = new Intent(LoginActivity.this, MainActivity.class);
                       }
                       
                       intent.putExtra("user_id", userId);
                       startActivity(intent);
                       finish();
                   }
                   
                   @Override
                   public void onError(String message) {
                       Toast.makeText(LoginActivity.this, message, Toast.LENGTH_SHORT).show();
                       loginButton.setEnabled(true);
                       loginButton.setText("Login");
                   }
               });
           });
       }
   }
   ```

================================================================================
                    SECURITY BEST PRACTICES
================================================================================

1. ALWAYS USE HTTPS
   ✓ Never send passwords over HTTP (plain text on network)
   ✓ Use HTTPS (SSL/TLS) to encrypt data in transit
   ✓ Configure Android to require HTTPS:
   
   ```xml
   <!-- res/xml/network_security_config.xml -->
   <network-security-config>
       <domain-config cleartextTrafficPermitted="false">
           <domain includeSubdomains="true">your-django-server.com</domain>
       </domain-config>
   </network-security-config>
   ```

2. NEVER STORE PLAIN PASSWORDS
   ✓ Never save passwords in SharedPreferences
   ✓ Never log passwords to console
   ✓ Only store authentication tokens
   ✓ Clear tokens on logout

3. TOKEN-BASED AUTHENTICATION
   ✓ Use JWT (JSON Web Tokens) or Django's built-in session tokens
   ✓ Tokens expire after certain time
   ✓ Refresh tokens before expiration
   ✓ Store tokens in EncryptedSharedPreferences

4. CERTIFICATE PINNING (Advanced)
   ✓ Pin your server's SSL certificate
   ✓ Prevents man-in-the-middle attacks
   ✓ Use OkHttp's CertificatePinner

5. NEVER ACCESS SUPABASE DIRECTLY FROM ANDROID
   ✗ Don't use Supabase SDK in Android app
   ✗ Don't expose database credentials in app
   ✓ Always go through Django API
   ✓ Django validates, authorizes, and protects data

================================================================================
                    WHY THIS ARCHITECTURE IS SECURE
================================================================================

1. SEPARATION OF CONCERNS
   - Android: User interface only
   - Django: Authentication logic, password verification
   - Supabase: Data storage only

2. PASSWORD NEVER LEAVES SERVER
   - Android sends plain password once (over HTTPS)
   - Django verifies password
   - Android receives token (not password)
   - Future requests use token (not password)

3. DEFENSE IN DEPTH
   Layer 1: HTTPS encryption (passwords encrypted in transit)
   Layer 2: Django authentication (password verification)
   Layer 3: PBKDF2 hashing (passwords hashed at rest)
   Layer 4: Unique salts (rainbow tables ineffective)
   Layer 5: 600,000 iterations (brute force impractical)

4. IF DATABASE IS COMPROMISED
   Attacker gets: "pbkdf2_sha256$600000$aB3xK9mP$7fJ2k..."
   Attacker cannot: Get original password
   Users are safe: Hashes cannot be reversed
   Bonus: Even weak passwords are protected by 600k iterations

================================================================================
                    COMMON MISTAKES TO AVOID
================================================================================

❌ MISTAKE 1: Storing passwords in Android app
   ```java
   // WRONG - NEVER DO THIS!
   SharedPreferences prefs = getSharedPreferences("user", MODE_PRIVATE);
   prefs.edit().putString("password", password).apply();
   ```

❌ MISTAKE 2: Comparing hashes in Android
   ```java
   // WRONG - THIS WILL NOT WORK!
   String dbHash = fetchHashFromSupabase();
   String userHash = hashPassword(userInput); // Same salt? Same iterations?
   if (dbHash.equals(userHash)) { /* Will fail */ }
   ```

❌ MISTAKE 3: Direct Supabase access
   ```java
   // WRONG - SECURITY RISK!
   SupabaseClient supabase = new SupabaseClientBuilder()
       .setUrl("https://xxx.supabase.co")
       .setKey("your-anon-key") // Exposed in app!
       .build();
   ```

❌ MISTAKE 4: Sending password in GET requests
   ```java
   // WRONG - PASSWORDS IN URL!
   String url = "https://api.com/login?username=john&password=secret123";
   // URL is logged everywhere, visible in browser history
   ```

❌ MISTAKE 5: Logging passwords
   ```java
   // WRONG - PASSWORD IN LOGS!
   Log.d("Login", "Password: " + password);
   ```

================================================================================
                    SUMMARY: THE CORRECT FLOW
================================================================================

SIGNUP (Creating Account):
   1. User enters password in Android app
   2. Android sends password to Django via HTTPS POST
   3. Django receives plain password
   4. Django's User.save() calls make_password()
   5. make_password() hashes with PBKDF2 + 600k iterations
   6. Hash stored in Supabase: "pbkdf2_sha256$600000$..."
   7. Android receives success response (NOT the hash)

LOGIN (Authentication):
   1. User enters password in Android app
   2. Android sends username + password to Django via HTTPS POST
   3. Django receives plain password
   4. Django calls authenticate(username, password)
   5. authenticate() fetches hash from Supabase
   6. Django's check_password() hashes input password with same salt
   7. Django compares computed hash with stored hash
   8. If match: Return user + token to Android
   9. If no match: Return error to Android
   10. Android stores token (NOT password) for future requests

AUTHENTICATED REQUESTS:
   1. Android includes token in Authorization header
   2. Django validates token
   3. Django allows/denies access
   4. Android receives data

LOGOUT:
   1. Android sends logout request with token
   2. Django invalidates token
   3. Android deletes token from storage

================================================================================
                    DJANGO BACKEND CODE REFERENCE
================================================================================

Your current implementation (already working):

Location: PBL/myapp/features/auth/views.py

```python
from django.contrib.auth import authenticate, login as auth_login
from django.contrib.auth.hashers import make_password, check_password

def signup(request):
    # Create user
    user = User(
        username=username,
        email=email,
        password=password,  # Plain text
        role=role
    )
    user.save()  # Automatically hashes password in User.save()
    # Password is now: pbkdf2_sha256$600000$...

def login(request):
    username = data.get("username")
    password = data.get("password")  # Plain text from Android
    
    # authenticate() handles everything:
    # 1. Fetch hash from Supabase
    # 2. Hash input password
    # 3. Compare hashes
    # 4. Return user or None
    user = authenticate(username=username, password=password)
    
    if user is not None:
        # Password verified successfully
        auth_login(request, user)
        return JsonResponse({
            "success": True,
            "redirect": "/dashboard"
        })
    else:
        # Wrong password
        return JsonResponse({
            "message": "Invalid credentials"
        }, status=401)
```

Location: PBL/myapp/models.py

```python
from django.contrib.auth.hashers import make_password

class User(AbstractBaseUser):
    password = models.TextField()
    
    def save(self, *args, **kwargs):
        # Automatically hash password if not already hashed
        if not self.password.startswith(('pbkdf2_sha256$', 'bcrypt$', 'argon2')):
            self.password = make_password(self.password)
        super(User, self).save(*args, **kwargs)
```

================================================================================
                    FINAL ANSWER TO YOUR QUESTION
================================================================================

Q: "How can my Android app read the password from Supabase?"

A: IT CANNOT AND IT SHOULD NOT!

The whole point of password hashing is that passwords CANNOT be read/decrypted.

CORRECT APPROACH:
   1. Android sends username + password to YOUR DJANGO SERVER
   2. Django verifies password using check_password()
   3. Django returns authentication token to Android
   4. Android uses token for future requests
   5. Password is NEVER stored or transmitted again

DO NOT:
   ✗ Try to decrypt hashes from Supabase
   ✗ Access Supabase directly from Android
   ✗ Store passwords in Android app
   ✗ Compare hashes in Android app

DO:
   ✓ Use Django API for all authentication
   ✓ Send passwords over HTTPS only
   ✓ Store tokens (not passwords) in Android
   ✓ Let Django handle all password verification

YOUR DJANGO SERVER IS ALREADY SET UP CORRECTLY!
Just use the /login/ and /signup/ endpoints from your Android app.

================================================================================
                    QUESTIONS & ANSWERS
================================================================================

Q: Why can't I just implement PBKDF2 in Android and hash the password there?
A: You could, but:
   - You'd need the exact salt from the database (stored with each password)
   - You'd need to fetch it securely
   - You'd expose your verification logic to attackers
   - It's unnecessary - let Django do it server-side
   - Server-side verification is more secure and centralized

Q: Can I store the hash in Android instead of the password?
A: No! The hash is just as sensitive as the password:
   - Anyone with the hash can authenticate (pass-the-hash attack)
   - Hashes should never leave the server
   - Store tokens instead - they expire and can be revoked

Q: How does Django know the salt for each user?
A: The salt is stored IN the hash itself:
   "pbkdf2_sha256$600000$[THIS_IS_THE_SALT]$[hash]"
   Django parses the hash to extract the salt, then uses it for comparison.

Q: Is HTTPS really necessary? Can't I just hash the password in Android first?
A: HTTPS is CRITICAL:
   - Even if you hash in Android, attacker can use that hash to log in
   - HTTPS encrypts the entire request (not just password)
   - HTTPS prevents man-in-the-middle attacks
   - HTTPS is required for production apps

Q: What if I want offline login?
A: Use biometric authentication (fingerprint/face) with encrypted token:
   - User logs in once with password (online)
   - Store encrypted token locally
   - Use biometrics to decrypt token for future logins
   - Periodically revalidate with server
   - NEVER store passwords offline

================================================================================
                    RESOURCES FOR ANDROID DEVELOPMENT
================================================================================

1. Retrofit (Recommended HTTP client):
   https://square.github.io/retrofit/

2. Volley (Google's HTTP library):
   https://developer.android.com/training/volley

3. EncryptedSharedPreferences:
   https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences

4. Network Security Configuration:
   https://developer.android.com/training/articles/security-config

5. JWT Authentication:
   https://jwt.io/

6. Django REST Framework (for better API):
   https://www.django-rest-framework.org/

================================================================================
                    CONTACT & SUPPORT
================================================================================

If you need help implementing the Android app:

1. API Endpoints Already Available:
   POST /login/      - User authentication
   POST /signup/     - User registration
   POST /logout/     - User logout
   GET  /dashboard/  - User dashboard (requires token)

2. Expected Request Format:
   {
       "username": "john",
       "password": "MyPassword123"
   }

3. Expected Response Format:
   Success:
   {
       "success": true,
       "token": "abc123...",
       "user_id": 123,
       "role": "patient",
       "redirect": "/dashboard"
   }
   
   Failure:
   {
       "success": false,
       "message": "Invalid credentials"
   }

4. Your Django server is ready - just connect your Android app to it!

================================================================================
                    END OF DOCUMENT
================================================================================

Remember: Security is not about making passwords "uncrackable" - it's about 
making them so expensive to crack that it's not worth the attacker's time.

With PBKDF2 + 600,000 iterations + unique salts, even a leaked database is 
useless to attackers. This is the CORRECT way to handle passwords.

Never try to "read" or "decrypt" passwords. Always verify them server-side.

================================================================================
